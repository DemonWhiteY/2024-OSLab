## 练习一

### 代码

将`sp`设置为栈顶，`epc`设置为文件的入口地址，`sstatus`的`SPP`位清零，代表异常来自用户态，之后需要返回用户态；`SPIE`位清零，表示不启用中断。

```c
tf->gpr.sp = USTACKTOP;
tf->epc = elf->e_entry;
tf->status = sstatus & ~(SSTATUS_SPP | SSTATUS_SPIE);
```

### 执行过程

1. 在`init_main`中通过`kernel_thread`调用`do_fork`创建并唤醒线程，使其执行函数`user_main`，这时该线程状态已经为`PROC_RUNNABLE`，表明该线程开始运行
2. 在`user_main`中通过宏`KERNEL_EXECVE`，调用`kernel_execve`
3. 在`kernel_execve`中执行`ebreak`，发生断点异常，转到`__alltraps`，转到`trap`，再到`trap_dispatch`，然后到`exception_handler`，最后到`CAUSE_BREAKPOINT`处
4. 在`CAUSE_BREAKPOINT`处调用`syscall`
5. 在`syscall`中根据参数，确定执行`sys_exec`，调用`do_execve`
6. 在`do_execve`中调用`load_icode`，加载文件
7. 加载完毕后一路返回，直到`__alltraps`的末尾，接着执行`__trapret`后的内容，到`sret`，表示退出S态，回到用户态执行，这时开始执行用户的应用程序

## 练习二

### 代码实现

```
uintptr_t* src = page2kva(page);
uintptr_t* dst = page2kva(npage);
memcpy(dst, src, PGSIZE);
ret = page_insert(to, npage, start, perm);
```

- 首先获取源地址和目的地址的虚拟地址

- 将数据从当前地址复制到目的地址

- 将虚拟地址映射到当前物理地址上，完成页插入

### COW设计

- 在fork时，子进程继承父进程的所有页表目录，并这些页面被标记为只读。

- 当子进程尝试修改页面时，需要访问并修改页表，内核会触发一个缺页异常，

- 触发异常后，系统会建立一个新的页表并将所需要修改的页表复制进去，然后修改复制后的页表，实现COW操作

## 练习三

#### **请分析fork/exec/wait/exit的执行流程。重点关注哪些操作是在用户态完成，哪些是在内核态完成？内核态与用户态程序是如何交错执行的？内核态执行结果是如何返回给用户程序的？**

- `fork`函数负责使用系统调用在当前进程下创建一个子进程，之后根据函数的返回值进行不同的处理。 在代码中，`fork`函数被定义成对系统调用用户态接口`sys_fork`（`syscall.c`）的封装，当用户态调用fork函数时，认为是执行正常的中断处理流程，最终会将控制权转交给`syscall`。函数内部通过内联汇编，将参数传递后执行`ecall`，产生`trap`，进入内核态进行异常处理，经过`trap.c`中的`exception_handler`处理句柄唤起对应的系统调用函数`sys_fork`，之后转发给`proc.c`的`do_fork`函数，随之完成对新进程的进程控制块的初始化、内容的设置以及进程列表的更新。
- 如果存在用户态调用的`exec()`，执行流程应该也会和上述`fork`函数一样，最终在`syscall.c`中被分配到`sys_exec`函数中，并在参数传递完成后调用`do_execve`函数。 `do_execve`函数负责回收进程自身所占用的空间，之后调用`load_icode`函数，用新的程序覆盖内存空间，形成一个执行新程序的新进程，同时设置好中断帧，使得中断返回后能够跳转到新的进程的入口处执行。
- `wait`函数主要负责在子进程退出时让父进程完成对进程所占剩余资源的彻底回收。`wait`函数被定义成对系统调用用户态接口`sys_wait`的封装，当用户态调用`wait`函数时，可以认为是执行正常的中断处理流程，最终会将控制权转交给`syscall`，函数内部通过内联汇编，将参数传递后执行`ecall`，产生`trap`，进入内核态进行异常处理，经过`trap.c`中的`exception_handler`处理句柄唤起对应的系统调用函数`sys_wai`t，之后转发给`proc.c`中的`do_wait`函数，开始搜索指定进程是否存在指定的`ZOMBIE`态子进程，找到则直接将其占用的所有剩余资源，如内核栈、进程控制块等全部释放；未找到则将进程状态设置为`SLEEPING`并设置等待状态为等待子进程、调用调度器切换到别的可执行进程，直至对应的子进程陷入`ZOMBIE`态唤醒这个父进程。
- `exit`函数负责在进程自身退出时释放所占用的大部分内存空间，同时唤醒父进程完成对自身不能回收的剩余空间的回收，并切换到其他进程。 `exit`函数被定义成对系统调用用户态接口`sys_exit`的封装，当用户态调用`exit`函数时，可以认为是执行正常的中断处理流程，最终会将控制权转交给`syscall`，函数内部通过内联汇编，将参数传递后执行`ecal`l，产生`trap`， 进入内核态进行异常处理，经过处理句柄唤起对应的系统调用函数`sys_exit`，之后转发给`proc.c`中的`do_exit`函数，释放当前进程的大部分资源，更改该进程状态为`ZOMBIE`，并在父进程进入`wait`等待状态时唤醒，调用调度器换出其他进程，等待父进程进一步完成对剩余资源的回收。

这些函数的调用都是在用户态发起的，用户态负责发出中断，传递对应的参数后执行`ecall`陷入到内核态，之后由内核态负责进行相应的系统调用处理，执行完成后，从`do_xxxx`函数开始反向将结果传递，`trap.c`中断处理完成后进入到`epc`下一条指令执行，同时返回值通过用户态`syscall`函数中内联汇编定义的返回值保存地址`ret`最终传递回用户程序。

#### **请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）**

```
                    +-------------+
               +--> |  none    |
               |    +-------------+       ---+
               |          | alloc_proc      |
               |          V         |
               |    +-------------+    |
               |    | PROC_UNINIT |    |---> do_fork
               |    +-------------+    |
      do_wait  |         | wakeup_proc   |
               |         V         ---+
               |    +-------------+    do_wait       +-------------+
               |    |PROC_RUNNABLE| <------------>    |PROC_SLEEPING|
               |    +-------------+    wake_up        +-------------+
               |         | do_exit
               |         V
               |    +-------------+
               +--- | PROC_ZOMBIE |
                    +-------------+
```
